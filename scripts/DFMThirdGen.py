from SSMTools import pcaEstMD, kalmanSmooth
import numpy as np
from scipy.signal import detrend

def estimateDFM(Y, nLF, maxIt=10):
    """
    Estimates the hidden states and observation matrix for a dynamic factor model using the "third generation"
    method. This entails first running PCA to estimate the loadings and hidden states, using these to estimate
    the parameters for the state space model, and feeding these estimates into the Kalman smoother.

    Note that this assumes the data is generated by a state space model whose hidden state is augmented by its
    derivative. The SSM's defining equations are: TODO

    Arguments
    -Y: N x T numpy array
        Array of data that has already been preprocessed.
    -nLF: int
        Number of dynamic factors to use. Note that the state space model will use 2 nLF factors since it
        augments the hidden state with derivatives of the factors.
    -maxIt: int
        Number of iterations to run of EM procedure for generating PCA estimates of loadings and hidden states
    -nObsForEst: int
        Number of observations at beginning of dataset to use for estimating initial state and velocity
        covariance.

    """
    # Estimate loadings and hidden state values with PCA
    _, lHat, fTHat = pcaEstMD(Y, nLF, maxIt=11)

    # Estimate SSM parameters using PCA estimate for loadings
    pi0Hat, sigma0Hat, CHat, QHat, RHat = augKFSetupFromPCA(Y, lHat, fTHat, nLF)

    # State transition matrix is known
    A = np.asarray(np.bmat([2*[np.identity(nLF)], [np.zeros([nLF, nLF]), np.identity(nLF)]]))

    # Run the smoother
    return CHat, kalmanSmooth(Y, pi0Hat, sigma0Hat, A, CHat, QHat, RHat, 2*nLF)[0]

def augKFSetupFromPCA(Y, lHat, fTHat, nLF, nObsForEst=20):
    """
    Sets up matrices, initial state and initial covariance estimates for the Kalman filter

    Arguments:
    -Y: N x T float array
        Data matrix
    -lHat: N x n_LF float array
        Loadings matrix. Assumes this matrix is normalized such that lHat^T lHat / N = I_{n_LF x n_LF}
    -fTHat: n_LF x T float array
        Hidden state estimate
    -nLF: int
        Number of latent factors
    -nObsForEst: int
        Number of observations at beginning of dataset to use for estimating initial state and velocity
        covariance.

    Returns
        Estimates for initial hidden state and covariance matrix, observation matrix C, hidden state noise
        variance Q, observation variance R
    """
    N = Y.shape[0]
    T = Y.shape[1]

    CHat = np.asarray(np.bmat([lHat, np.zeros([N, nLF])])) # using loadings in observation matrix

    # Estimate velocities
    vHat = np.zeros([nLF, T])
    vHat[:, 1:] = fTHat[:, 1:] - fTHat[:, 0:-1]
    vHat[:, 0] = np.mean(vHat[:, 1:nObsForEst], axis=1) # guess for the initial velocity

    # Combine into state estimate
    XHat = np.asarray(np.bmat([[fTHat], [vHat]]))

    # Estimate variance, which can be pushed into the velocity equation, by detrending
    # TODO: is there a better way to do this?
    QHat = np.asarray(np.bmat([2*[np.zeros([nLF, nLF])], \
                [np.zeros([nLF, nLF]), np.diag(np.var(detrend(vHat[:, 0:nObsForEst]), axis=1, ddof=1))]]))

    # Estimate observation variance
    RHat = np.diag(np.nanvar(Y - np.dot(CHat, XHat), axis=1, ddof=1))

    # Crappy estimates of initial values of mu and sigma
    # TODO: improve this
    XHat0 = XHat[:, 0].copy().T
    sigma0 = np.var(detrend(XHat[:, 0:nObsForEst])) #QHat

    return XHat0, sigma0, CHat, QHat, RHat


